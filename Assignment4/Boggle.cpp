#include <iostream>
#include "gboggle.h"
#include "grid.h"
#include "gwindow.h"
#include "lexicon.h"
#include "random.h"
#include "simpio.h"
using namespace std;

/* Constants */

const int BOGGLE_WINDOW_WIDTH = 650;
const int BOGGLE_WINDOW_HEIGHT = 350;

const string STANDARD_CUBES[16]  = {
    "AAEEGN", "ABBJOO", "ACHOPS", "AFFKPS",
    "AOOTTW", "CIMOTU", "DEILRX", "DELRVY",
    "DISTTY", "EEGHNW", "EEINSU", "EHRTVW",
    "EIOSST", "ELRTTY", "HIMNQU", "HLNNRZ"
};
 
const string BIG_BOGGLE_CUBES[25]  = {
    "AAAFRS", "AAEEEE", "AAFIRS", "ADENNN", "AEEEEM",
    "AEEGMU", "AEGMNN", "AFIRSY", "BJKQXZ", "CCNSTW",
    "CEIILT", "CEILPT", "CEIPST", "DDLNOR", "DDHNOT",
    "DHHLOR", "DHLNOR", "EIIITT", "EMOTTT", "ENSSSU",
    "FIPRSY", "GORRVW", "HIPRRY", "NOOTUW", "OOOTTU"
};

const int MIN_LENGTH = 4;
Lexicon lexicon("EnglishWords.dat");

/* Function prototypes */

void welcome();
void giveInstructions();
void boardConfiguration(int &boardSize, bool &autoGeneration);
void drawAutoBoard(Grid<char> &boardGrid, Vector<char> &boardLetters,int &boardSize);
void drawGeneratedBoard(Grid<char> &boardGrid, Vector<char> &boardLetters,int &boardSize);
void playerPart(Player &player,Grid<char> &boardGrid,Grid<bool> &usedLetters, Set<string> &usedWords, int &boardSize);
bool wordExists(string word, Grid<char> &boardGrid, int x1,int y1,int x2, int y2, Grid<bool> &highlights, Grid<bool> &usedLetters);
void selectHighlights(Grid<bool> &highlights);
void clearGrid(Grid<bool> &grid);
void computerPart(Player player,Grid<char> &boardGrid,string word,int x,int y,Set<string>&usedWords,Grid<bool> &usedSquares);

/* Main program */
int main() {

    GWindow gw(BOGGLE_WINDOW_WIDTH, BOGGLE_WINDOW_HEIGHT);
    initGBoggle(gw);
    
	int boardSize;
	bool autoGeneration;
	Grid<char> boardGrid; // a main grid
	Vector<char> boardLetters; // letters of the main grid
	Grid<bool> usedLetters; //letters that are already used for a single word
	Grid<bool> usedSquares; //squares that are used during computer-part recursion
	Set <string> usedWords; //words which a player has already guessed
	Player player;
	Grid<bool> falseHighlights; // every member is 'false'. needed in a recurent function in computer's part.
	
	welcome();
    giveInstructions();

	while(true){

	boardConfiguration(boardSize,autoGeneration);//gets a size of board and whether it should be autogenerated.
	boardGrid.resize(boardSize,boardSize);//set a size
	
	if(autoGeneration) drawAutoBoard(boardGrid,boardLetters,boardSize);
	else drawGeneratedBoard(boardGrid,boardLetters,boardSize);

	
	usedLetters.resize(boardSize,boardSize);//set a size
	player = HUMAN;
	
	playerPart(player,boardGrid,usedLetters,usedWords,boardSize);
	
	player=COMPUTER;
	usedSquares.resize(boardSize,boardSize);
	
	//startpoint for each step is a different square
	for(int i=0;i<boardSize*boardSize;i++){
		int x=i/boardSize;
		int y=i%boardSize;
		computerPart(player,boardGrid,"",x,y,usedWords,usedSquares);
		clearGrid(usedSquares);
	}
	
	cout<<"Do you want to play again?"<<endl;
	string choice=getLine();
	if(choice=="no") break;

	//if a game continues, everithyng should be clear.
	clearGrid(usedLetters);
	boardLetters.clear();
	usedWords.clear();
	}
    return 0;
}

void welcome() {
    cout << "Welcome!  You're about to play an intense game ";
    cout << "of mind-numbing Boggle.  The good news is that ";
    cout << "you might improve your vocabulary a bit.  The ";
    cout << "bad news is that you're probably going to lose ";
    cout << "miserably to this little dictionary-toting hunk ";
    cout << "of silicon.  If only YOU had a gig of RAM..." << endl << endl;
}

void giveInstructions() {
    cout << endl;
    cout << "The boggle board is a grid onto which I ";
    cout << "I will randomly distribute cubes. These ";
    cout << "6-sided cubes have letters rather than ";
    cout << "numbers on the faces, creating a grid of ";
    cout << "letters on which you try to form words. ";
    cout << "You go first, entering all the words you can ";
    cout << "find that are formed by tracing adjoining ";
    cout << "letters. Two letters adjoin if they are next ";
    cout << "to each other horizontally, vertically, or ";
    cout << "diagonally. A letter can only be used once ";
    cout << "in each word. Words must be at least four ";
    cout << "letters long and can be counted only once. ";
    cout << "You score points based on word length: a ";
    cout << "4-letter word is worth 1 point, 5-letters ";
    cout << "earn 2 points, and so on. After your puny ";
    cout << "brain is exhausted, I, the supercomputer, ";
    cout << "will find all the remaining words and double ";
    cout << "or triple your paltry score." << endl << endl;
    cout << "Hit return when you're ready...";
    getLine();
}

void boardConfiguration(int &boardSize, bool &autoGeneration){
	
	string choice;

	cout<<"You can choose standard Boggle (4x4 grid) or Big Boogle (5x5)."<<endl;
	cout<<"Would you like Big Boogle?"<<endl;
	choice = getLine();
	if(choice=="yes") boardSize = 5;
	else boardSize = 4;
	
	cout<<"Do you want to set up the board to your specification?"<<endl;
	choice = getLine();
	autoGeneration = (choice == "no");

}

//randomly generated board
void drawAutoBoard(Grid<char> &boardGrid, Vector<char> &boardLetters,int &boardSize){
	Vector<string> cubes;

	if(boardSize==4){
		for(int i=0;i<boardSize*boardSize;i++){
			cubes.add(STANDARD_CUBES[i]);
		}
	} else{
		for(int i=0;i<boardSize*boardSize;i++){
			cubes.add(BIG_BOGGLE_CUBES[i]);
		}
	}

	for (int i=0;i<cubes.size();i++) {
	int n=randomInteger(0,cubes.size()-1);
	swap(cubes[n],cubes[i]);
	}

	drawBoard(boardSize,boardSize);
	
	for (int i=0;i<cubes.size();i++) {
		int n=randomInteger(0,5);
		labelCube(i/boardSize,i%boardSize,cubes[i][n]);
		boardGrid[i/boardSize][i%boardSize]=cubes[i][n];
		boardLetters.add(cubes[i][n]);
	}
}

//customly generated board
void drawGeneratedBoard(Grid<char> &boardGrid, Vector<char> &boardLetters,int &boardSize){
	cout<<"Enter a "<<boardSize*boardSize<<"-character string"<<endl;
	string chars = getLine();
	drawBoard(boardSize,boardSize);
	for (int i=0;i<chars.length();i++) {
		labelCube(i/boardSize,i%boardSize,chars[i]);
		boardGrid[i/boardSize][i%boardSize]=chars[i];
		boardLetters.add(chars[i]);
	}

}

void playerPart(Player &player,Grid<char> &boardGrid,Grid<bool> &usedLetters, Set<string> &usedWords, int &boardSize){
	Grid<bool> highlights(boardSize,boardSize);
	while(true){
		string word = getLine("Enter a word:");
		
		if(word.length()==0){
			return;
		}
		word = toLowerCase(word);
		//'wordExists' is a recurrent function which also updates current data,
		//such as the letters that should be highlighted.
		if (word.length()<MIN_LENGTH || usedWords.contains(word) || 
		!lexicon.contains(word) || !wordExists(word,boardGrid,0,0,boardSize-1,boardSize-1,highlights,usedLetters)){
			cout<<"That word isn't valid, try another one:"<<endl;
			continue;
		} else{
			usedWords.add(word);//saves the word as already used
			recordWordForPlayer(word,player);
			selectHighlights(highlights);//highlights proper letters on the board
		}
		clearGrid(highlights);// cleans the highlight grid
		selectHighlights(highlights);//cleans highlight marks from board
	}

}

// makes each member of a boolean grid 'false'
void clearGrid(Grid<bool> &grid){
	for (int i=0;i<grid.numCols();i++){
		for (int j=0;j<grid.numCols();j++) {
			grid[i][j]=false;
		}
	}
}

//recurent function which finds wheter a word can be found on the board
bool wordExists(string word, Grid<char> &boardGrid, int x1,int y1,int x2, int y2, Grid<bool> &highlights, Grid<bool> &usedLetters){
		if (word.length()==0)
		return true;
	//initial coordinate variables(x1,y1,x2,y2) are zeros and size()-1, which means that function considers a whole grid
	for (int i=x1;i<=x2;i++)
		for (int j=y1;j<=y2;j++)
			if (boardGrid[i][j]==word[0] && !usedLetters[i][j]) {
				usedLetters[i][j]=true;
				// this time recurrent step considers a sub-grid which consists of a particular letter and its neighbours.
				// min() and max() functions ar needed in case of 'out of bounds error'
				if (wordExists(word.substr(1),boardGrid,max(0,i-1),max(0,j-1),min(boardGrid.numCols()-1,i+1),min(boardGrid.numCols()-1,j+1),highlights,usedLetters)) { 
						usedLetters[i][j]=false;
						highlights[i][j]=true;
						return true;
				}
				usedLetters[i][j]=false;
			}

	return false;
}

//highlights particular letters
void selectHighlights(Grid<bool> &highlights){
	for (int i=0;i<highlights.numCols();i++){
		for (int j=0;j<highlights.numCols();j++){
			highlightCube(i,j,(highlights[i][j]));
		}
	}
}

void computerPart(Player player,Grid<char> &boardGrid,string word,int x,int y,Set<string> &usedWords,Grid<bool> &usedSquares) {

	word+=boardGrid[x][y];
	usedSquares[x][y]=true;

	if (!lexicon.containsPrefix(word)) {
		return;
	}
	//checks if generated string is a word.
	if (word.length()>=MIN_LENGTH && !usedWords.contains(word) && lexicon.contains(word)) {
			
			usedWords.add(word);
			recordWordForPlayer(word,player);
	}
	
	//recursive steps for each neighbours of a square
	for (int i=-1;i<=1;i++){
		for(int j=-1;j<=1;j++){
			
			int x1 = x+i;
			int y1 = y+j;
			if(!boardGrid.inBounds(x1,y1)) continue;
			if(usedSquares[x1][y1]) continue;
			
			usedSquares[x1][y1]=true;
			computerPart(player,boardGrid,word,x1,y1,usedWords,usedSquares);
			usedSquares[x1][y1]=false;
		}
	}
	
}


